# Cross Device Screen Time Tracker – System Design

## 1. Product Definition

The Cross Device Screen Time Tracker is a system designed to measure foreground application engagement time on desktop devices and synchronize usage data to a centralized backend.

The system measures:
- Time spent actively using a specific foreground application
- Only while the system is unlocked
- Only when the screen session is active

It does **not** measure:
- Background app time
- Pixel-level screen visibility
- Pure device uptime

The philosophy aligns with engagement-based tracking (similar to Digital Wellbeing), focusing on meaningful foreground usage.

## 2. High-Level Architecture

System components:

### Website (User Interface)
- User authentication (Email + Password)
- Dashboard and analytics
- Device management
- Desktop link token generation

### Backend API (ASP.NET Core)
- JWT-based authentication
- Device linking system
- Device authentication (Device JWT)
- Time log validation and storage

### Desktop Application (C#)
- Foreground window tracking
- Local aggregation and SQLite storage
- Chunked sync to backend
- Auto-start with Windows
- Offline-first behavior

## 3. Authentication Model

### 3.1 User Authentication
- Email + Password login
- Backend issues User JWT
- JWT signed using HMAC (server secret)
- Used only for website/API access

### 3.2 Desktop Linking Flow
1. User logs into website.
2. User generates a one-time Desktop Link Token.
3. Backend:
	- Generates 32+ byte cryptographically secure random token
	- Stores SHA256 hash of token
	- Sets expiration (5–10 minutes)
	- Marks `IsUsed = false`
4. User pastes token into desktop app.
5. Desktop sends:
	- Raw token
	- `DeviceName` (auto-detected)
6. Backend:
	- Hashes received token
	- Validates existence, expiry, and unused status
	- Marks token as used
	- Creates new `Device` record
	- Issues Device JWT

### 3.3 Device Authentication (Device JWT)

Device JWT contains:
- `DeviceId` (GUID generated by backend)
- `UserId`
- `TokenVersion`

Validation flow:
1. Validate JWT signature.
2. Load device from database.
3. Confirm:
	- Device exists
	- `Device.UserId` matches `JWT.UserId`
	- `Device.TokenVersion` matches `JWT.TokenVersion`
	- `Device.IsRevoked == false`

Server database is the source of truth.

## 4. Database Schema

### 4.1 Devices Table

Fields:
- `Id` (GUID, generated by backend)
- `UserId` (FK)
- `DeviceName`
- `CreatedAt`
- `LastDataSyncAt`
- `IsRevoked` (bool)
- `TokenVersion` (int)

Rules:
- `TokenVersion` increments to invalidate all existing tokens.
- `LastDataSyncAt` updates only on successful log sync.

### 4.2 DesktopLinkTokens Table

Fields:
- `Id` (GUID)
- `UserId` (FK)
- `TokenHash` (SHA256, unique)
- `ExpiresAt`
- `IsUsed` (bool)
- `CreatedAt`

Rules:
- Only one active (unused + unexpired) token per user.
- `TokenHash` has a unique index.
- Old tokens are removed by scheduled cleanup job.
- Raw tokens are never stored.

## 5. Desktop Application Architecture

### 5.1 Tracking Logic

Desktop app:
- Polls active foreground window
- Tracks system lock/unlock state
- Uses monotonic timer (e.g., `Stopwatch`) for duration calculation
- Uses system UTC time for timestamps

When:
- App changes → close previous block
- System locks → close block
- 5 minutes elapsed → close block (chunking)

Each block contains:
- `AppName`
- `StartTimeUtc`
- `EndTimeUtc`
- `DurationSeconds` (calculated using monotonic timer)

### 5.2 Local Storage (SQLite)

Each time block is stored locally with:
- `Id`
- `AppName`
- `StartTimeUtc`
- `EndTimeUtc`
- `DurationSeconds`
- `SyncStatus` (Pending / Sent / Failed)
- `ErrorMessage` (optional)

This ensures:
- Crash safety
- Offline support
- Reliable retry logic

## 6. Sync Strategy

### 6.1 Batch Processing
- Logs sent in small chunks (e.g., 100 records)
- Not one giant payload

If success:
- Mark logs as Sent
- Update `LastDataSyncAt`

If validation error:
- Mark as Failed
- Continue with next chunk

If network/server error:
- Keep as Pending
- Retry later

### 6.2 Backend Validation

Backend:
- Recalculates duration using `EndTime - StartTime`
- Compares with client duration (tolerance allowed)
- Validates:
  - No extreme duration
  - No invalid timestamps
  - Device ownership
  - TokenVersion match
  - `IsRevoked == false`

Server-computed duration is stored.

Client data is treated as hint, not authority.

## 7. Revocation Strategy

User may:
- Revoke individual device
- Logout from all devices

Implementation:
- Increment `TokenVersion` to invalidate existing tokens
- Or set `IsRevoked = true`

No blacklist is used.

JWT remains stateless but controllable via DB verification.

## 8. Offline-First Behavior

If desktop cannot reach backend:
- Continue tracking
- Store locally
- Retry sync later

On startup:
- Desktop verifies device status via lightweight endpoint
- If revoked → require re-link
- If network unavailable → continue offline

## 9. Auto-Start and UX Philosophy

Desktop app:
- Auto-starts with Windows
- Runs in system tray
- Minimal UI

Shows:
- Connection status
- Last sync time
- Re-link option

All analytics and device management are handled on website.

## 10. Security Principles
- Never trust client duration.
- Never trust client identity without DB verification.
- Hash all temporary tokens.
- Use GUIDs for device identifiers.
- Use monotonic timer for duration measurement.
- Validate time drift.
- Enforce device ownership checks.
- Server database is the ultimate authority.