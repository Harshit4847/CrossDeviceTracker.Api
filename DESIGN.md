# Cross Device Screen Time Tracker – System Design

## 1. Product Definition

The Cross Device Screen Time Tracker is a system designed to measure foreground application engagement time on desktop devices and synchronize usage data to a centralized backend.

The system measures:

* Time spent actively using a specific foreground application
* Only while the system is unlocked
* Only when the screen session is active

It does **not** measure:

* Background app time
* Pixel-level screen visibility
* Pure device uptime

The philosophy aligns with engagement-based tracking (similar to Digital Wellbeing), focusing on meaningful foreground usage.

## 2. High-Level Architecture

System components:

### Website (User Interface)

* User authentication (Email + Password)
* Dashboard and analytics
* Device management
* Desktop link token generation

### Backend API (ASP.NET Core)

* JWT-based authentication
* Device linking system
* Device authentication (Device JWT)
* Time log validation and storage

### Desktop Application (C#)

* Foreground window tracking
* Local aggregation and SQLite storage
* Chunked sync to backend
* Auto-start with Windows
* Offline-first behavior

## 3. Authentication Model

### 3.1 User Authentication

* Email + Password login
* Backend issues User JWT
* JWT signed using HMAC (server secret)
* Used only for website/API access

### 3.2 Desktop Linking Flow

1. User logs into website.
2. User generates a one-time Desktop Link Token.
3. Backend:

   * Generates 32+ byte cryptographically secure random token
   * Stores SHA256 hash of token
   * Sets expiration (5–10 minutes)
   * Marks `IsUsed = false`
4. User pastes token into desktop app.
5. Desktop sends:

   * Raw token
   * `DeviceName` (auto-detected)
6. Backend:

   * Hashes received token
   * Validates existence, expiry, and unused status
   * Marks token as used
   * Creates new `Device` record
   * Issues Device JWT

### 3.3 Device Authentication (Device JWT)

Device JWT contains:

* `DeviceId` (GUID generated by backend)
* `UserId`
* `TokenVersion`

Validation flow:

1. Validate JWT signature.
2. Load device from database.
3. Confirm:

   * Device exists
   * `Device.UserId` matches `JWT.UserId`
   * `Device.TokenVersion` matches `JWT.TokenVersion`
   * `Device.IsRevoked == false`

Server database is the source of truth.

## 4. Database Schema

### 4.1 Devices Table

Fields:

* `Id` (GUID, generated by backend)
* `UserId` (FK)
* `DeviceName`
* `CreatedAt`
* `LastDataSyncAt`
* `IsRevoked` (bool)
* `TokenVersion` (int)

Rules:

* `TokenVersion` increments to invalidate all existing tokens.
* `LastDataSyncAt` updates only on successful log sync.

### 4.2 DesktopLinkTokens Table

Fields:

* `Id` (GUID)
* `UserId` (FK)
* `TokenHash` (SHA256, unique)
* `ExpiresAt`
* `IsUsed` (bool)
* `CreatedAt`

Rules:

* Only one active (unused + unexpired) token per user.
* `TokenHash` has a unique index.
* Old tokens are removed by scheduled cleanup job.
* Raw tokens are never stored.

## 5. Desktop Application Architecture

### 5.1 Tracking Logic

Desktop app:

* Polls active foreground window
* Tracks system lock/unlock state
* Uses monotonic timer (e.g., `Stopwatch`) for duration calculation
* Uses system UTC time for timestamps

When:

* App changes → close previous block
* System locks → close block
* 5 minutes elapsed → close block (chunking)

Each block contains:

* `AppName`
* `StartTimeUtc`
* `EndTimeUtc`
* `DurationSeconds` (calculated using monotonic timer)

### 5.2 Local Storage (SQLite)

Each time block is stored locally with:

* `Id`
* `AppName`
* `StartTimeUtc`
* `EndTimeUtc`
* `DurationSeconds`
* `SyncStatus` (Pending / Sent / Failed)
* `ErrorMessage` (optional)

This ensures:

* Crash safety
* Offline support
* Reliable retry logic

## 6. Sync Strategy

### 6.1 Batch Processing

* Logs sent in small chunks (e.g., 100 records)
* Not one giant payload

If success:

* Mark logs as Sent
* Update `LastDataSyncAt`

If validation error:

* Mark as Failed
* Continue with next chunk

If network/server error:

* Keep as Pending
* Retry later

### 6.2 Backend Validation

Backend:

* Recalculates duration using `EndTime - StartTime`
* Compares with client duration (tolerance allowed)
* Validates:

  * No extreme duration
  * No invalid timestamps
  * Device ownership
  * TokenVersion match
  * `IsRevoked == false`

Server-computed duration is stored.

Client data is treated as a hint, not authority.

## 7. Revocation Strategy

User may:

* Revoke individual device
* Logout from all devices

Implementation:

* Increment `TokenVersion` to invalidate existing tokens
* Or set `IsRevoked = true`

No blacklist is used.

JWT remains stateless but controllable via DB verification.

## 8. Offline-First Behavior

If desktop cannot reach backend:

* Continue tracking
* Store locally
* Retry sync later

On startup:

* Desktop verifies device status via lightweight endpoint
* If revoked → require re-link
* If network unavailable → continue offline

## 9. Auto-Start and UX Philosophy

Desktop app:

* Auto-starts with Windows
* Runs in system tray
* Minimal UI

Shows:

* Connection status
* Last sync time
* Re-link option

All analytics and device management are handled on website.

## 10. Security Principles

* Never trust client duration.
* Never trust client identity without DB verification.
* Hash all temporary tokens.
* Use GUIDs for device identifiers.
* Use monotonic timer for duration measurement.
* Validate time drift.
* Enforce device ownership checks.
* Server database is the ultimate authority.

---

## 11. DesktopLinkToken – Final Design Specification

### 11.1 Purpose

DesktopLinkToken is a one-time credential used to securely link a desktop application to a user account.

It:

* Is generated by backend
* Is short-lived (temporary)
* Is returned once in raw form
* Can be consumed only once
* Is hashed in the database
* Is treated as an authentication credential
* Is not recoverable after generation

### 11.2 Core Invariant

At any time, a user can have at most one unused DesktopLinkToken.

And:

* A DesktopLinkToken can be consumed only one time.
* Raw token is never stored in the database.
* Database is the source of truth for concurrency safety.

### 11.3 Entity Structure

Fields:

* `Id` → Guid
* `UserId` → Guid (FK)
* `User` → Navigation property
* `TokenHash` → byte[] (SHA256 hash)
* `ExpiresAt` → DateTimeOffset
* `CreatedAt` → DateTimeOffset
* `IsUsed` → bool (default false)

#### Constructor Rules

Public constructor requires:

* `userId`
* `tokenHash`
* `expiresAt`

Inside constructor:

* Generate `Id`
* Set `CreatedAt = DateTimeOffset.UtcNow`
* Set `IsUsed = false`
* Assign `TokenHash`
* Assign `UserId`
* Assign `ExpiresAt`

Private parameterless constructor is required for EF Core.

#### State Transition

`IsUsed`:

* Uses private setter
* Is changed only through `MarkAsUsed()`

`MarkAsUsed()` should throw if token is already used.

State machine:

* `Unused` → `Used` (irreversible)

### 11.4 Database Constraints

#### Unique Partial Index

`UNIQUE(UserId) WHERE IsUsed = false`

Guarantees:

* Only one unused token per user
* Prevents race condition on generation

#### TokenHash

* SHA256 (32 bytes)
* Stored as `byte[]`
* Raw token NEVER stored
* Hash is unique

### 11.5 Token Generation Flow

Inside a transaction:

1. Delete all unused tokens for the user.
2. Generate 32 cryptographically secure random bytes.
3. Hash bytes using SHA256.
4. Create new `DesktopLinkToken` entity:

   * `TokenHash = hash`
   * `ExpiresAt = UtcNow + ConfiguredExpiry`
   * `CreatedAt = UtcNow`
   * `IsUsed = false`
5. `SaveChanges` once.
6. Commit transaction.
7. Return raw token (URL-safe Base64 of original bytes).

Raw token handling:

* Never stored
* Never logged
* Never recoverable

### 11.6 Expiry Policy

* Expiry duration is stored in configuration (IConfiguration / Options).
* Not hardcoded.
* Not stored per user.
* Only `ExpiresAt` timestamp stored in DB.

### 11.7 Token Format

* Generated using cryptographic RNG (32 bytes minimum).
* Returned as URL-safe Base64.
* Padding removed.
* Safe for copy-paste and transport.

### 11.8 Token Validation (Linking Flow)

When desktop sends token:

Inside a transaction:

1. Decode URL-safe Base64 → bytes.
2. Hash bytes → SHA256.
3. Query token by `TokenHash`.
4. Validate:

   * Exists
   * Not expired
   * Not used
5. Call `MarkAsUsed()`.
6. Create `Device` entity.
7. `SaveChanges` once.
8. Commit transaction.
9. Issue Device JWT.

### 11.9 Security Rules

* Raw token is never stored.
* Hash only stored.
* Hash is compared using constant-time comparison.
* Invalid token always returns:

  * `401 Unauthorized`
  * Generic message: "Invalid linking token"

Do not reveal:

* Expired
* Used
* Not found

All are treated the same.

### 11.10 Concurrency Protection

#### During Generation

* Partial unique index prevents two unused tokens.
* Transaction ensures atomic delete + insert.
* On constraint violation → return `409 Conflict`.

#### During Consumption

* Token state transition (Unused → Used) inside transaction.
* Device creation inside same transaction.
* Prevents double linking.

### 11.11 HTTP Status Rules

#### Generate Token

* Success → `200 OK`
* If unused token already exists (race) → `409 Conflict`

#### Consume Token

* Success → `200 OK`
* Invalid / expired / used → `401 Unauthorized`

### 11.12 Architectural Principles Applied

* Defense in depth
* DB as source of truth
* Atomic state transitions
* Secure randomness
* Hash-only secret storage
* Constant-time comparisons
* No sensitive information leakage
* Config-driven policy
* Domain-driven design principles
* Explicit state transitions
* Separation of policy (configuration) from data (DB)
* Clean REST semantics
